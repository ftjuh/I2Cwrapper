<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>I2Cwrapper: I2Cwrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">I2Cwrapper<span id="projectnumber">&#160;v0.3.0</span>
   </div>
   <div id="projectbrief">Generic framework for Arduino I2C target devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_i2_cwrapper.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_i2_cwrapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">I2Cwrapper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A helper class for the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> and related libraries.  
 <a href="class_i2_cwrapper.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A helper class for the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> and related libraries. </p>
<p >I split it from an earlier version of the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> library when adding Servo support, to be able to have a clean separation librarywise between the two: The wrapper represents the I2C target and handles all communication with it. <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a>, <a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a>, and others use it for communicating with the target. To do so, an <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> object is instantiated with the target's I2C address and then passed to its client object's (<a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> etc.) constructor. </p><dl class="section user"><dt>Command codes</dt><dd><ul>
<li>000 - 009 (reserved)</li>
<li>010 - 049 <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a></li>
<li>050 - 059 <a class="el" href="class_servo_i2_c.html" title="An I2C wrapper class for the Arduino Servo library.">ServoI2C</a></li>
<li>060 - 069 <a class="el" href="class_pin_i2_c.html" title="An I2C wrapper class for remote analog and digital pin control.">PinI2C</a></li>
<li>070 - 074 <a class="el" href="class_e_s_p32sensors_i2_c.html" title="An I2C wrapper class for ESP32 sensors (touch, temp, hall).">ESP32sensorsI2C</a></li>
<li>075 - 079 (unused)</li>
<li>080 - 089 <a class="el" href="class_t_m1638lite_i2_c.html" title="An I2C wrapper class for Danny Ayers&#39; TM1638lite library (https://www.arduino.cc/reference/en/librari...">TM1638liteI2C</a></li>
<li>090 - 239 (unused)</li>
<li>240 - 255 <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> commands (reset target, change address etc.) </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>New classes could use <a class="el" href="class_i2_cwrapper.html" title="A helper class for the AccelStepperI2C and related libraries.">I2Cwrapper</a> to easily add even more capabilities to the target, e.g. for driving DC motors, granted that the firmware is extended accordingly and the above list of uint8_t command codes is kept free from duplicates. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0dfd77031c47e17a1b1cb833eceed3fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a0dfd77031c47e17a1b1cb833eceed3fa">I2Cwrapper</a> (uint8_t <a class="el" href="firmware_8ino.html#afd5dbf719bae2b1ea9260a55e7c289cf">i2c_address</a>, uint8_t maxBuf=<a class="el" href="_i2_cwrapper_8h.html#ad73c883bc137fdc05d0447439c740b26">I2CmaxBuf</a>)</td></tr>
<tr class="memdesc:a0dfd77031c47e17a1b1cb833eceed3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_i2_cwrapper.html#a0dfd77031c47e17a1b1cb833eceed3fa">More...</a><br /></td></tr>
<tr class="separator:a0dfd77031c47e17a1b1cb833eceed3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efa3b87ade5a202bd57255fcf6a5bbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a8efa3b87ade5a202bd57255fcf6a5bbe">ping</a> ()</td></tr>
<tr class="memdesc:a8efa3b87ade5a202bd57255fcf6a5bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if target device is listening.  <a href="class_i2_cwrapper.html#a8efa3b87ade5a202bd57255fcf6a5bbe">More...</a><br /></td></tr>
<tr class="separator:a8efa3b87ade5a202bd57255fcf6a5bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2712bde196b501809ef5eba90e498f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a2712bde196b501809ef5eba90e498f5c">reset</a> (unsigned long resetDelay=<a class="el" href="_i2_cwrapper_8h.html#a1d6006d51ea23f9641a437ce5326b962">defaultResetDelay</a>)</td></tr>
<tr class="memdesc:a2712bde196b501809ef5eba90e498f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the target device to reset to its default state. It is recommended to reset the target every time the controller is started or restarted to put it in a defined state. Else it could happen that the target still manages units (steppers, etc.) which the controller does not know about.  <a href="class_i2_cwrapper.html#a2712bde196b501809ef5eba90e498f5c">More...</a><br /></td></tr>
<tr class="separator:a2712bde196b501809ef5eba90e498f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8084b9fc49113a5a6d2214e1878457e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#ab8084b9fc49113a5a6d2214e1878457e">changeI2Caddress</a> (uint8_t <a class="el" href="_change__address_8ino.html#a53811bf61b46bdfb67602aeafbb0b739">newAddress</a>)</td></tr>
<tr class="memdesc:ab8084b9fc49113a5a6d2214e1878457e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently change the I2C address of the device. The new address is stored in EEPROM (AVR) or flash memory (ESPs) and will be active after the next reset/reboot.  <a href="class_i2_cwrapper.html#ab8084b9fc49113a5a6d2214e1878457e">More...</a><br /></td></tr>
<tr class="separator:ab8084b9fc49113a5a6d2214e1878457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32301b5659f124217e59413192849dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a32301b5659f124217e59413192849dde">setInterruptPin</a> (int8_t pin, bool activeHigh=true)</td></tr>
<tr class="memdesc:a32301b5659f124217e59413192849dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a global interrupt pin which can be used by device units (steppers, servos...) to inform the controller that something important happend. Currently used by <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> to inform about end stop hits and target reached events, and <a class="el" href="class_e_s_p32sensors_i2_c.html" title="An I2C wrapper class for ESP32 sensors (touch, temp, hall).">ESP32sensorsI2C</a> to inform a touched button event.  <a href="class_i2_cwrapper.html#a32301b5659f124217e59413192849dde">More...</a><br /></td></tr>
<tr class="separator:a32301b5659f124217e59413192849dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1365ca44e217ce79bcfc3fe0c2ee7cac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a1365ca44e217ce79bcfc3fe0c2ee7cac">clearInterrupt</a> ()</td></tr>
<tr class="memdesc:a1365ca44e217ce79bcfc3fe0c2ee7cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge to target that interrupt has been received, so that the target can clear the interupt condition and return the reason for the interrupt.  <a href="class_i2_cwrapper.html#a1365ca44e217ce79bcfc3fe0c2ee7cac">More...</a><br /></td></tr>
<tr class="separator:a1365ca44e217ce79bcfc3fe0c2ee7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512ca27376efd779426fcd836e629e2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#aa512ca27376efd779426fcd836e629e2">setI2Cdelay</a> (unsigned long delay)</td></tr>
<tr class="memdesc:aa512ca27376efd779426fcd836e629e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a minimum duration of time that the controller keeps between I2C transmissions. This is to make sure that the target has finished its earlier task or has its answer to the controller's previous command ready. Particularly for ESP32 targets this is critical, as due to its implementation of I2C target mode, an ESP32 could theoretically send incomplete data if a request is sent too early. The actual delay will take the time spent since the last I2C transmission into account, so that it won't wait at all if the given time has already passed.  <a href="class_i2_cwrapper.html#aa512ca27376efd779426fcd836e629e2">More...</a><br /></td></tr>
<tr class="separator:aa512ca27376efd779426fcd836e629e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03edf9e2b6cda53ae2c6380ad6dade08"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a03edf9e2b6cda53ae2c6380ad6dade08">getI2Cdelay</a> ()</td></tr>
<tr class="memdesc:a03edf9e2b6cda53ae2c6380ad6dade08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns currently set I2Cdelay.  <a href="class_i2_cwrapper.html#a03edf9e2b6cda53ae2c6380ad6dade08">More...</a><br /></td></tr>
<tr class="separator:a03edf9e2b6cda53ae2c6380ad6dade08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dd6653d03a02c1c4efb1d7edec9140"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#aa3dd6653d03a02c1c4efb1d7edec9140">autoAdjustI2Cdelay</a> (uint8_t maxLength=<a class="el" href="_i2_cwrapper_8h.html#ad73c883bc137fdc05d0447439c740b26">I2CmaxBuf</a> - 3, uint8_t safetyMargin=2, uint8_t startWith=<a class="el" href="_i2_cwrapper_8h.html#a8e670dbec664a89d717caad5333aa8a4">I2CdefaultDelay</a>)</td></tr>
<tr class="memdesc:aa3dd6653d03a02c1c4efb1d7edec9140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C delay to the smallest value that still allows error free transmissions. To determine this value, a simulation test is run: A number of dummy transmissions are repeatedly exchanged with the target using the pingBack() function, while successively decreasing the I2C delay. The test will stop as soon as a transmission error occurs. The smallest error free value (or 0 ms), increased by the safety margin, will be set as the new I2C delay.  <a href="class_i2_cwrapper.html#aa3dd6653d03a02c1c4efb1d7edec9140">More...</a><br /></td></tr>
<tr class="separator:aa3dd6653d03a02c1c4efb1d7edec9140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d42c3ddaa5ea8c69b879a6b316038c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a30d42c3ddaa5ea8c69b879a6b316038c">getVersion</a> ()</td></tr>
<tr class="memdesc:a30d42c3ddaa5ea8c69b879a6b316038c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get semver compliant version of target firmware.  <a href="class_i2_cwrapper.html#a30d42c3ddaa5ea8c69b879a6b316038c">More...</a><br /></td></tr>
<tr class="separator:a30d42c3ddaa5ea8c69b879a6b316038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7b0b5ff8c1252676b9ff1bbdbe24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#ab8e7b0b5ff8c1252676b9ff1bbdbe24d">checkVersion</a> (uint32_t controllerVersion)</td></tr>
<tr class="memdesc:ab8e7b0b5ff8c1252676b9ff1bbdbe24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version of target firmware and compare it with library version.  <a href="class_i2_cwrapper.html#ab8e7b0b5ff8c1252676b9ff1bbdbe24d">More...</a><br /></td></tr>
<tr class="separator:ab8e7b0b5ff8c1252676b9ff1bbdbe24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99818d9f4b28834ce7611759c6b45032"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032">sentErrors</a> ()</td></tr>
<tr class="memdesc:a99818d9f4b28834ce7611759c6b45032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and reset the number of failed commands sent since the last time this method was used. A command is sent each time a function call is transmitted to the target.  <a href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032">More...</a><br /></td></tr>
<tr class="separator:a99818d9f4b28834ce7611759c6b45032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595582aa091af76fc27c472d081db4db"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db">resultErrors</a> ()</td></tr>
<tr class="memdesc:a595582aa091af76fc27c472d081db4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and reset the number of failed receive events since the last time this method was used. A receive event happens each time a function returns a value from the target.  <a href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db">More...</a><br /></td></tr>
<tr class="separator:a595582aa091af76fc27c472d081db4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26fad87074cea9cf636cbd49226c8c5"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#af26fad87074cea9cf636cbd49226c8c5">transmissionErrors</a> ()</td></tr>
<tr class="memdesc:af26fad87074cea9cf636cbd49226c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and reset the sum of failed commands sent <em>and</em> failed receive events since the last time this method was used. Use this if you are only interested in the sum of all transmission errors, not in what direction the errors occurred.  <a href="class_i2_cwrapper.html#af26fad87074cea9cf636cbd49226c8c5">More...</a><br /></td></tr>
<tr class="separator:af26fad87074cea9cf636cbd49226c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f424cf28f8044a69b8ae94bb3d7292d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a7f424cf28f8044a69b8ae94bb3d7292d">prepareCommand</a> (uint8_t cmd, uint8_t unit=-1)</td></tr>
<tr class="separator:a7f424cf28f8044a69b8ae94bb3d7292d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dc95baffdae6e8cfe07ea902fc926b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a64dc95baffdae6e8cfe07ea902fc926b">sendCommand</a> ()</td></tr>
<tr class="separator:a64dc95baffdae6e8cfe07ea902fc926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd966608c453a72646dfe37e061fee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#adfd966608c453a72646dfe37e061fee7">readResult</a> (uint8_t numBytes)</td></tr>
<tr class="separator:adfd966608c453a72646dfe37e061fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3b285450dd823865580c281c06bded4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_simple_buffer.html">SimpleBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#af3b285450dd823865580c281c06bded4">buf</a></td></tr>
<tr class="separator:af3b285450dd823865580c281c06bded4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3023339571c205c161a82576fd4f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#a51c3023339571c205c161a82576fd4f4">sentOK</a> = false</td></tr>
<tr class="memdesc:a51c3023339571c205c161a82576fd4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if previous function call was successfully transferred to target.  <a href="class_i2_cwrapper.html#a51c3023339571c205c161a82576fd4f4">More...</a><br /></td></tr>
<tr class="separator:a51c3023339571c205c161a82576fd4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d76a351cee8c7ce48f87d13e27dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i2_cwrapper.html#abf0d76a351cee8c7ce48f87d13e27dbc">resultOK</a> = false</td></tr>
<tr class="memdesc:abf0d76a351cee8c7ce48f87d13e27dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if return value from previous function call was received successfully.  <a href="class_i2_cwrapper.html#abf0d76a351cee8c7ce48f87d13e27dbc">More...</a><br /></td></tr>
<tr class="separator:abf0d76a351cee8c7ce48f87d13e27dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0dfd77031c47e17a1b1cb833eceed3fa" name="a0dfd77031c47e17a1b1cb833eceed3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfd77031c47e17a1b1cb833eceed3fa">&#9670;&nbsp;</a></span>I2Cwrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I2Cwrapper::I2Cwrapper </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxBuf</em> = <code><a class="el" href="_i2_cwrapper_8h.html#ad73c883bc137fdc05d0447439c740b26">I2CmaxBuf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_address</td><td>Address of the target device </td></tr>
    <tr><td class="paramname">maxBuf</td><td>Upper limit of send and receive buffer including 1 crc8 byte </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3dd6653d03a02c1c4efb1d7edec9140" name="aa3dd6653d03a02c1c4efb1d7edec9140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dd6653d03a02c1c4efb1d7edec9140">&#9670;&nbsp;</a></span>autoAdjustI2Cdelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2Cwrapper::autoAdjustI2Cdelay </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLength</em> = <code><a class="el" href="_i2_cwrapper_8h.html#ad73c883bc137fdc05d0447439c740b26">I2CmaxBuf</a>&#160;-&#160;3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>safetyMargin</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>startWith</em> = <code><a class="el" href="_i2_cwrapper_8h.html#a8e670dbec664a89d717caad5333aa8a4">I2CdefaultDelay</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C delay to the smallest value that still allows error free transmissions. To determine this value, a simulation test is run: A number of dummy transmissions are repeatedly exchanged with the target using the pingBack() function, while successively decreasing the I2C delay. The test will stop as soon as a transmission error occurs. The smallest error free value (or 0 ms), increased by the safety margin, will be set as the new I2C delay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLength</td><td>Number of simulated test parameter bytes sent with each testing transmission, defaulting to the maximum bytes that are possible with the given I2C buffer size. This theoretical maximum (I2CmaxBuf minus three bytes for the message header) will not be fully used by most modules. So if you know what the maximum number of parameter bytes sent or receiced by any of the commands you will use in your project is, you can specify it here to get a more aggressive, shorter I2C delay. Leave it to the default to be on the safe side, in most cases it should not make a significant difference. </td></tr>
    <tr><td class="paramname">safetyMargin</td><td>A number of microseconds that will be added to the empirically determined minimum I2C delay. As the test transmissions do nothing but send back the amount of specified simulated parameter bytes, you will want to specify some extra time to allow for the time the controller will need to process any given command on top of the pure transmissions. Its optimal value fully depends on how fast the target's module(s) do their job. It should usually be at least 1 ms. For the included modules 2 ms are a safe bet, that's why it's used as the default. </td></tr>
    <tr><td class="paramname">startWith</td><td>The delay value in ms to start with, defaults to I2CdefaultDelay (20 ms). Mainly meant to be used if serial debugging is enabled in the target firmware. If there is heavy debugging output, the default I2CdefaultDelay may sometimes be too low. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>new in v0.3.0, experimental </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly set I2C delay </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#aa512ca27376efd779426fcd836e629e2" title="Define a minimum duration of time that the controller keeps between I2C transmissions....">setI2Cdelay()</a> </dd></dl>

</div>
</div>
<a id="ab8084b9fc49113a5a6d2214e1878457e" name="ab8084b9fc49113a5a6d2214e1878457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8084b9fc49113a5a6d2214e1878457e">&#9670;&nbsp;</a></span>changeI2Caddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cwrapper::changeI2Caddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>newAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently change the I2C address of the device. The new address is stored in EEPROM (AVR) or flash memory (ESPs) and will be active after the next reset/reboot. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#a2712bde196b501809ef5eba90e498f5c" title="Tells the target device to reset to its default state. It is recommended to reset the target every ti...">reset()</a> </dd></dl>

</div>
</div>
<a id="ab8e7b0b5ff8c1252676b9ff1bbdbe24d" name="ab8e7b0b5ff8c1252676b9ff1bbdbe24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7b0b5ff8c1252676b9ff1bbdbe24d">&#9670;&nbsp;</a></span>checkVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::checkVersion </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>controllerVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version of target firmware and compare it with library version. </p>
<dl class="section return"><dt>Returns</dt><dd>true if both versions match, i.a. are compatible. </dd></dl>

</div>
</div>
<a id="a1365ca44e217ce79bcfc3fe0c2ee7cac" name="a1365ca44e217ce79bcfc3fe0c2ee7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1365ca44e217ce79bcfc3fe0c2ee7cac">&#9670;&nbsp;</a></span>clearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2Cwrapper::clearInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge to target that interrupt has been received, so that the target can clear the interupt condition and return the reason for the interrupt. </p>
<dl class="section return"><dt>Returns</dt><dd>Reason for the interrupt as 8bit BCD with triggering unit in lower 4 bits and trigger reason in the upper 4 bits. 0xff in case of error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___interrupt_reasons.html" title="Used by clearInterrup() to inform the controller about what caused the previous interrupt.">List of possible reasons an interrupt was triggered.</a> </dd></dl>

</div>
</div>
<a id="a03edf9e2b6cda53ae2c6380ad6dade08" name="a03edf9e2b6cda53ae2c6380ad6dade08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03edf9e2b6cda53ae2c6380ad6dade08">&#9670;&nbsp;</a></span>getI2Cdelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long I2Cwrapper::getI2Cdelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns currently set I2Cdelay. </p>

</div>
</div>
<a id="a30d42c3ddaa5ea8c69b879a6b316038c" name="a30d42c3ddaa5ea8c69b879a6b316038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d42c3ddaa5ea8c69b879a6b316038c">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2Cwrapper::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get semver compliant version of target firmware. </p>
<dl class="section return"><dt>Returns</dt><dd>major version in bits 0-7, minor version in bits 8-15; patch version in bits 16-23; 0xFFFFFFFF on error. </dd></dl>

</div>
</div>
<a id="a8efa3b87ade5a202bd57255fcf6a5bbe" name="a8efa3b87ade5a202bd57255fcf6a5bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efa3b87ade5a202bd57255fcf6a5bbe">&#9670;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if target device is listening. </p>
<dl class="section return"><dt>Returns</dt><dd>true if target could be found under the given address. </dd></dl>

</div>
</div>
<a id="a7f424cf28f8044a69b8ae94bb3d7292d" name="a7f424cf28f8044a69b8ae94bb3d7292d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f424cf28f8044a69b8ae94bb3d7292d">&#9670;&nbsp;</a></span>prepareCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cwrapper::prepareCommand </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>unit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfd966608c453a72646dfe37e061fee7" name="adfd966608c453a72646dfe37e061fee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd966608c453a72646dfe37e061fee7">&#9670;&nbsp;</a></span>readResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::readResult </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2712bde196b501809ef5eba90e498f5c" name="a2712bde196b501809ef5eba90e498f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2712bde196b501809ef5eba90e498f5c">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cwrapper::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>resetDelay</em> = <code><a class="el" href="_i2_cwrapper_8h.html#a1d6006d51ea23f9641a437ce5326b962">defaultResetDelay</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the target device to reset to its default state. It is recommended to reset the target every time the controller is started or restarted to put it in a defined state. Else it could happen that the target still manages units (steppers, etc.) which the controller does not know about. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetDelay</td><td>(new in v0.3.0, optional) delay in ms that the controller waits after sending the reset command to give the target enough time to reinitialize the firmware core and the activated modules. Defaults to defaultResetDelay (100 ms), 10 ms would probably be more than enough for all current modules. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a595582aa091af76fc27c472d081db4db" name="a595582aa091af76fc27c472d081db4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595582aa091af76fc27c472d081db4db">&#9670;&nbsp;</a></span>resultErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2Cwrapper::resultErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return and reset the number of failed receive events since the last time this method was used. A receive event happens each time a function returns a value from the target. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032" title="Return and reset the number of failed commands sent since the last time this method was used....">sentErrors()</a>, <a class="el" href="class_i2_cwrapper.html#af26fad87074cea9cf636cbd49226c8c5" title="Return and reset the sum of failed commands sent and failed receive events since the last time this m...">transmissionErrors()</a> </dd></dl>

</div>
</div>
<a id="a64dc95baffdae6e8cfe07ea902fc926b" name="a64dc95baffdae6e8cfe07ea902fc926b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dc95baffdae6e8cfe07ea902fc926b">&#9670;&nbsp;</a></span>sendCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::sendCommand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99818d9f4b28834ce7611759c6b45032" name="a99818d9f4b28834ce7611759c6b45032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99818d9f4b28834ce7611759c6b45032">&#9670;&nbsp;</a></span>sentErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2Cwrapper::sentErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return and reset the number of failed commands sent since the last time this method was used. A command is sent each time a function call is transmitted to the target. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db" title="Return and reset the number of failed receive events since the last time this method was used....">resultErrors()</a>, <a class="el" href="class_i2_cwrapper.html#af26fad87074cea9cf636cbd49226c8c5" title="Return and reset the sum of failed commands sent and failed receive events since the last time this m...">transmissionErrors()</a> </dd></dl>

</div>
</div>
<a id="aa512ca27376efd779426fcd836e629e2" name="aa512ca27376efd779426fcd836e629e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512ca27376efd779426fcd836e629e2">&#9670;&nbsp;</a></span>setI2Cdelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long I2Cwrapper::setI2Cdelay </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a minimum duration of time that the controller keeps between I2C transmissions. This is to make sure that the target has finished its earlier task or has its answer to the controller's previous command ready. Particularly for ESP32 targets this is critical, as due to its implementation of I2C target mode, an ESP32 could theoretically send incomplete data if a request is sent too early. The actual delay will take the time spent since the last I2C transmission into account, so that it won't wait at all if the given time has already passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Minimum time in between I2C transmissions in milliseconds. The default I2CdefaultDelay is a bit conservative at 10 ms to allow for for serial debugging output to slow things down. You can try to go lower, if target debugging is disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the previously set delay. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#aa3dd6653d03a02c1c4efb1d7edec9140" title="Set I2C delay to the smallest value that still allows error free transmissions. To determine this val...">autoAdjustI2Cdelay()</a> </dd></dl>

</div>
</div>
<a id="a32301b5659f124217e59413192849dde" name="a32301b5659f124217e59413192849dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32301b5659f124217e59413192849dde">&#9670;&nbsp;</a></span>setInterruptPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2Cwrapper::setInterruptPin </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activeHigh</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a global interrupt pin which can be used by device units (steppers, servos...) to inform the controller that something important happend. Currently used by <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> to inform about end stop hits and target reached events, and <a class="el" href="class_e_s_p32sensors_i2_c.html" title="An I2C wrapper class for ESP32 sensors (touch, temp, hall).">ESP32sensorsI2C</a> to inform a touched button event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin the target will use to send out interrupts. </td></tr>
    <tr><td class="paramname">activeHigh</td><td>If true, HIGH will signal an interrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_accel_stepper_i2_c.html#a0015e762b6a5ab8a545574e1642358ef" title="Start or stop sending interrupts to controller for this stepper. An interrupt will be sent whenever a...">AccelStepperI2C::enableInterrupts()</a> </dd></dl>

</div>
</div>
<a id="af26fad87074cea9cf636cbd49226c8c5" name="af26fad87074cea9cf636cbd49226c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26fad87074cea9cf636cbd49226c8c5">&#9670;&nbsp;</a></span>transmissionErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2Cwrapper::transmissionErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return and reset the sum of failed commands sent <em>and</em> failed receive events since the last time this method was used. Use this if you are only interested in the sum of all transmission errors, not in what direction the errors occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>Sum of <a class="el" href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032" title="Return and reset the number of failed commands sent since the last time this method was used....">sentErrors()</a> and <a class="el" href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db" title="Return and reset the number of failed receive events since the last time this method was used....">resultErrors()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i2_cwrapper.html#a99818d9f4b28834ce7611759c6b45032" title="Return and reset the number of failed commands sent since the last time this method was used....">sentErrors()</a>, <a class="el" href="class_i2_cwrapper.html#a595582aa091af76fc27c472d081db4db" title="Return and reset the number of failed receive events since the last time this method was used....">resultErrors()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3b285450dd823865580c281c06bded4" name="af3b285450dd823865580c281c06bded4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b285450dd823865580c281c06bded4">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_simple_buffer.html">SimpleBuffer</a> I2Cwrapper::buf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf0d76a351cee8c7ce48f87d13e27dbc" name="abf0d76a351cee8c7ce48f87d13e27dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0d76a351cee8c7ce48f87d13e27dbc">&#9670;&nbsp;</a></span>resultOK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::resultOK = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if return value from previous function call was received successfully. </p>

</div>
</div>
<a id="a51c3023339571c205c161a82576fd4f4" name="a51c3023339571c205c161a82576fd4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c3023339571c205c161a82576fd4f4">&#9670;&nbsp;</a></span>sentOK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2Cwrapper::sentOK = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if previous function call was successfully transferred to target. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_i2_cwrapper_8h.html">I2Cwrapper.h</a></li>
<li><a class="el" href="_i2_cwrapper_8cpp.html">I2Cwrapper.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_i2_cwrapper.html">I2Cwrapper</a></li>
    <li class="footer">Generated on Tue Jul 5 2022 14:23:58 for I2Cwrapper by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
